use core::fmt;
use std::{
    sync::{Arc, Mutex},
    task::{Context, Poll},
};

use futures::{channel::mpsc, StreamExt};
use libp2p::core::{transport::PortUse, Endpoint, Multiaddr};
use libp2p::PeerId;
use libp2p::swarm::{
    self as swarm, dial_opts::DialOpts, ConnectionDenied, ConnectionId, FromSwarm,
    NetworkBehaviour, THandler, THandlerInEvent, THandlerOutEvent, ToSwarm,
};
use swarm::{
    behaviour::ConnectionEstablished, dial_opts::PeerCondition, ConnectionClosed, DialError,
    DialFailure,
};
use super::events::FromBehaviourToSwarm;
use super::{handler::Handler, shared::Shared, Control};

/// A generic behaviour for stream-oriented protocols.
pub struct Behaviour {
    shared: Arc<Mutex<Shared>>,
    dial_receiver: mpsc::Receiver<PeerId>,
}

impl Default for Behaviour {
    fn default() -> Self {
        Self::new()
    }
}

impl Behaviour {
    pub fn new() -> Self {
        let (dial_sender, dial_receiver) = mpsc::channel(0);

        Self {
            shared: Arc::new(Mutex::new(Shared::new(dial_sender))),
            dial_receiver,
        }
    }

    /// Obtain a new [`Control`].
    pub fn new_control(&self) -> Control {
        Control::new(self.shared.clone())
    }
}

/// The protocol is already registered.
#[derive(Debug)]
pub struct AlreadyRegistered;

impl fmt::Display for AlreadyRegistered {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "The protocol is already registered")
    }
}

impl std::error::Error for AlreadyRegistered {}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = Handler;
    // the top-level event exposed in the event loop
    type ToSwarm = FromBehaviourToSwarm;

    /*
    Callback that is invoked for every established inbound connection.

    This is invoked once another peer has successfully dialed us.

    At this point, we have verified their PeerId and we know, which particular Multiaddr succeeded in the dial. In order to actually use this connection, this function must return a ConnectionHandler. Returning an error will immediately close the connection.

    Note when any composed behaviour returns an error the connection will be closed and a FromSwarm::ListenFailure event will be emitted.

    */    
    fn handle_established_inbound_connection(
        &mut self,
        connection_id: ConnectionId,
        remote_peer: libp2p::PeerId,
        _local_addr: &Multiaddr,
        _remote_addr: &Multiaddr,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Ok(Handler::new(
            remote_peer,
            self.shared.clone(),
            Shared::lock(&self.shared).receiver(remote_peer, connection_id),
        ))
    }

    /*
    Callback that is invoked for every established outbound connection.

    This is invoked once we have successfully dialed a peer. At this point, we have verified their PeerId and we know, which particular Multiaddr succeeded in the dial. In order to actually use this connection, this function must return a ConnectionHandler. Returning an error will immediately close the connection.

    Note when any composed behaviour returns an error the connection will be closed and a FromSwarm::DialFailure event will be emitted.

    */
    fn handle_established_outbound_connection(
        &mut self,
        connection_id: ConnectionId,
        remote_peer: PeerId,
        _remote_addr: &Multiaddr,
        _: Endpoint,
        _: PortUse,
    ) -> Result<THandler<Self>, ConnectionDenied> {
        Ok(Handler::new(
            remote_peer,
            self.shared.clone(),
            Shared::lock(&self.shared).receiver(remote_peer, connection_id),
        ))
    }

    /*
    Informs the behaviour about an event generated by the swarm.
    */
    fn on_swarm_event(&mut self, event: FromSwarm) {
        match event {
            FromSwarm::ConnectionEstablished(ConnectionEstablished {
                peer_id,
                connection_id,
                ..
            }) => Shared::lock(&self.shared).on_connection_established(connection_id, peer_id),
            FromSwarm::ConnectionClosed(ConnectionClosed { connection_id, .. }) => {
                Shared::lock(&self.shared).on_connection_closed(connection_id)
            }
            FromSwarm::DialFailure(DialFailure {
                peer_id: Some(peer_id),
                error:
                    error @ (DialError::Transport(_)
                    | DialError::Denied { .. }
                    | DialError::NoAddresses
                    | DialError::WrongPeerId { .. }),
                ..
            }) => {
                let reason = error.to_string(); // We can only forward the string repr but it is better than nothing.

                Shared::lock(&self.shared).on_dial_failure(peer_id, reason)
            }
            _ => {}
        }
    }

    
    /*
    Informs the behaviour about an event generated by the ConnectionHandler dedicated to the peer identified by peer_id. for the behaviour.

    The PeerId is guaranteed to be in a connected state. In other words, FromSwarm::ConnectionEstablished has previously been received with this PeerId.
    */
    fn on_connection_handler_event(
        &mut self,
        _peer_id: PeerId,
        _connection_id: ConnectionId,
        event: THandlerOutEvent<Self>,
    ) {
    }

    
    /*
    Polls for things that swarm should do.

    This API mimics the API of the Stream trait. The method may register the current task in order to wake it up at a later point in time.
    */
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<ToSwarm<Self::ToSwarm, THandlerInEvent<Self>>> {
        
        if let Poll::Ready(Some(peer)) = self.dial_receiver.poll_next_unpin(cx) {
            return Poll::Ready(ToSwarm::Dial {
                opts: DialOpts::peer_id(peer)
                    .condition(PeerCondition::DisconnectedAndNotDialing)
                    .build(),
            });
        }

        Poll::Pending
    }
}
